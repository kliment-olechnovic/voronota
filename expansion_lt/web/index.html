<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Voronota-LT Web</title>
		<style>
			table
			{
				border-collapse: collapse;
			}
			
			table, td, th
			{
			  border: 1px solid black;
			  padding: 5px;
			  text-align: left;
			}

			tr:hover
			{
				background-color:#ccccff;
			}
		</style>
</head>
<body>
	<h1>Voronota-LT Web</h1>

	<div id="container-for-input">
		<label for="fileInput">Input file:</label>
		<input id="fileInput" type="file" autocomplete="off"/>
	</div>

	<div id="container-for-actions">
		<button onclick="runVoronotaLT()">Run Voronota-LT</button>
	</div>

	<div id="container-for-input-info"></div>
	
	<div id="container-for-error-log"></div>

	<div id="container-for-log"></div>
	
	<div id="container-for-links"></div>
	
	<script src="voronota_lt_web.js"></script>
	
	<script>
		function generateAndOpenPage(tsvContent, filename)
		{
			let htmlContent = `
				<!DOCTYPE html>
				<html lang="en">
				<head>
					<meta charset="UTF-8">
					<meta name="viewport" content="width=device-width, initial-scale=1.0">
					<title>${filename}</title>
					<style>
						table
						{
							border-collapse: collapse;
						}

						table, td, th
						{
							border: 1px solid black;
							padding: 5px;
							text-align: left;
						}
					</style>
				</head>
				<body>
					<h1>Viewing: ${filename}</h1>
					<table>
			`;

			const rows = tsvContent.split('\n').map(row => row.split('\t'));
			rows.forEach((row, index) => {
				if(row[0])
				{
					htmlContent += '<tr>';
					row.forEach(cell => {
						htmlContent += (index === 0 ? `<th>${cell}</th>` : `<td>${cell}</td>`);
					});
					htmlContent += '</tr>\n';
				}
			});

			const finalHtmlContent = htmlContent + `
					</table>
				</body>
				</html>
			`;

			const newWindow = window.open('', '_blank');
			newWindow.document.write(finalHtmlContent);
			newWindow.document.close();
		}
	</script>
	
	<script>
		let Module;
		(async () => { Module = await createVoronotaLTWebModule(); })();

		async function runVoronotaLT()
		{
			const container_for_input_info = document.getElementById("container-for-input-info");
			container_for_input_info.innerHTML = "";

			const container_for_error_log = document.getElementById("container-for-error-log");
			container_for_error_log.innerHTML = "";

			const container_for_log = document.getElementById("container-for-log");
			container_for_log.innerHTML = "";

			const container_for_links = document.getElementById("container-for-links");
			container_for_links.innerHTML = "";

			const fileInput = document.getElementById("fileInput");

			if(fileInput.files.length === 0)
			{
				alert("Please provide an input file.");
				return;
			}

			const file = fileInput.files[0];
			const reader = new FileReader();

			container_for_input_info.innerHTML = "<h2>Input overview</h2>";

			{
				const cell1 = document.createElement("td");
				const cell2 = document.createElement("td");
				cell1.textContent="Input file name";
				cell2.textContent=file.name;
				const trow = document.createElement("tr");
				trow.appendChild(cell1);
				trow.appendChild(cell2);
				const tbody = document.createElement("tbody");
				tbody.appendChild(trow);
				const table = document.createElement("table");
				table.appendChild(tbody);
				container_for_input_info.appendChild(table);
			}

			container_for_error_log.innerHTML = "<h2>Running ...</h2>";

			setTimeout(async () => {
				reader.onload = async () => {
					const input_content = reader.result;

					const vector = Module.generate_results(input_content);
					const strings = [];
					for(let i=0;i<vector.size();i++)
					{
						strings.push(vector.get(i));
					}
					vector.delete();

					container_for_error_log.innerHTML = "";

					const tbody_for_log = document.createElement("tbody");
					const tbody_for_links = document.createElement("tbody");

					let error_message="";
					let error_status=0;

					for(let index=0;index<strings.length && error_status==0;index+=2)
					{
						const i1=index;
						const i2=index+1;

						if(i2>=strings.length)
						{
							error_message+="Failed to produce valid output.\n";
							error_status=1;
						}
						else
						{
							if(strings[i1]=="error")
							{
								error_message+=strings[i2]+"\n";
								error_status=2;
							}
							else if(strings[i1]=="log_total_input_balls")
							{
								const cell1 = document.createElement("td");
								const cell2 = document.createElement("td");
								cell1.textContent="Input atoms";
								cell2.textContent=strings[i2];
								const trow = document.createElement("tr");
								trow.appendChild(cell1);
								trow.appendChild(cell2);
								tbody_for_log.appendChild(trow);
							}
							else if(strings[i1]=="log_total_contacts_count")
							{
								const cell1 = document.createElement("td");
								const cell2 = document.createElement("td");
								cell1.textContent="Atom-level contacts";
								cell2.textContent=strings[i2];
								const trow = document.createElement("tr");
								trow.appendChild(cell1);
								trow.appendChild(cell2);
								tbody_for_log.appendChild(trow);
							}
							else if(strings[i1]=="log_total_contacts_area")
							{
								const cell1 = document.createElement("td");
								const cell2 = document.createElement("td");
								cell1.textContent="Total contacts area";
								cell2.textContent=strings[i2];
								const trow = document.createElement("tr");
								trow.appendChild(cell1);
								trow.appendChild(cell2);
								tbody_for_log.appendChild(trow);
							}
							else if(strings[i1]=="log_total_residue_level_contacts_count")
							{
								const cell1 = document.createElement("td");
								const cell2 = document.createElement("td");
								cell1.textContent="Residue-level contacts";
								cell2.textContent=strings[i2];
								const trow = document.createElement("tr");
								trow.appendChild(cell1);
								trow.appendChild(cell2);
								tbody_for_log.appendChild(trow);
							}
							else if(strings[i1]=="log_total_chain_level_contacts_count")
							{
								const cell1 = document.createElement("td");
								const cell2 = document.createElement("td");
								cell1.textContent="Chain-level contacts";
								cell2.textContent=strings[i2];
								const trow = document.createElement("tr");
								trow.appendChild(cell1);
								trow.appendChild(cell2);
								tbody_for_log.appendChild(trow);
							}
							else if(strings[i1]=="log_total_cells_count")
							{
								const cell1 = document.createElement("td");
								const cell2 = document.createElement("td");
								cell1.textContent="Atom-level cell summaries";
								cell2.textContent=strings[i2];
								const trow = document.createElement("tr");
								trow.appendChild(cell1);
								trow.appendChild(cell2);
								tbody_for_log.appendChild(trow);
							}
							else if(strings[i1]=="log_total_cells_sas_area")
							{
								const cell1 = document.createElement("td");
								const cell2 = document.createElement("td");
								cell1.textContent="Total SAS area of cells";
								cell2.textContent=strings[i2];
								const trow = document.createElement("tr");
								trow.appendChild(cell1);
								trow.appendChild(cell2);
								tbody_for_log.appendChild(trow);
							}
							else if(strings[i1]=="log_total_cells_sas_inside_volume")
							{
								const cell1 = document.createElement("td");
								const cell2 = document.createElement("td");
								cell1.textContent="Total volume inside cells";
								cell2.textContent=strings[i2];
								const trow = document.createElement("tr");
								trow.appendChild(cell1);
								trow.appendChild(cell2);
								tbody_for_log.appendChild(trow);
							}
							else if(strings[i1]=="log_total_residue_level_cells_count")
							{
								const cell1 = document.createElement("td");
								const cell2 = document.createElement("td");
								cell1.textContent="Residue-level cell summaries";
								cell2.textContent=strings[i2];
								const trow = document.createElement("tr");
								trow.appendChild(cell1);
								trow.appendChild(cell2);
								tbody_for_log.appendChild(trow);
							}
							else if(strings[i1]=="log_total_chain_level_cells_count")
							{
								const cell1 = document.createElement("td");
								const cell2 = document.createElement("td");
								cell1.textContent="Chain-level cell summaries";
								cell2.textContent=strings[i2];
								const trow = document.createElement("tr");
								trow.appendChild(cell1);
								trow.appendChild(cell2);
								tbody_for_log.appendChild(trow);
							}
							else if(strings[i2])
							{
								const trow = document.createElement("tr");

								const filename=(strings[i1]+".tsv");
								const blob = new Blob([strings[i2]], { type: "text/plain" });
								const kilobytes=(blob.size/1024);
								const megabytes=(kilobytes/1024);


								{
									const cell = document.createElement("td");
									cell.textContent=filename;
									trow.appendChild(cell);
								}

								{
									const cell = document.createElement("td");
									if(megabytes<5)
									{
										const link = document.createElement("a");
										link.href = "#";
										link.textContent = "view";
										link.style.display = "block";
										link.onclick = (event) => {
											event.preventDefault();
											generateAndOpenPage(strings[i2], filename);
										};
										cell.appendChild(link);
									}
									else
									{
										cell.textContent="";
									}
									trow.appendChild(cell);
								}

								{
									const url = URL.createObjectURL(blob);
									const link = document.createElement("a");
									link.href = url;
									link.download = filename;
									link.textContent = "download";
									link.style.display = "block";
									link.onclick = () => setTimeout(() => URL.revokeObjectURL(url), 100);
									const cell = document.createElement("td");
									cell.appendChild(link);
									trow.appendChild(cell);
								}

								{
									const cell = document.createElement("td");
									if(megabytes<1)
									{
										cell.textContent=""+kilobytes.toFixed(2)+" KB";
									}
									else
									{
										cell.textContent=""+megabytes.toFixed(2)+" MB";
									}
									trow.appendChild(cell);
								}

								tbody_for_links.appendChild(trow);
							}
						}
					}

					if(error_message)
					{
						container_for_error_log.innerHTML = "<h2>Error log</h2>";
						const textfield = document.createElement("pre");
						textfield.textContent=error_message;
						container_for_error_log.appendChild(textfield);
					}

					if(error_status==0)
					{
						{
							container_for_log.innerHTML = "<h2>Output summary</h2>";
							const table = document.createElement("table");
							table.appendChild(tbody_for_log);
							container_for_log.appendChild(table);
						}

						{
							container_for_links.innerHTML = "<h2>Output files</h2>";
							const table = document.createElement("table");
							table.appendChild(tbody_for_links);
							container_for_links.appendChild(table);
						}
					}
				};

			}, 0);

			reader.readAsText(file);
		}
	</script>
</body>
</html>

