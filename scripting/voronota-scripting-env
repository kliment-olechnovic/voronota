#!/bin/bash

function print_help_and_exit
{
cat >&2 << 'EOF'

'voronota-scripting-env' script provides a way to run a Bash script that controls Voronota.

Options:
    --input | -i           string      input script file
    --string | -s          string      input script string
    --gui | -g                         flag to run 'voronota-viewer'
    --no-gui | -t                      flag to not run 'voronota-viewer' even if V_GUI is set to true
    --help | -h                        flag to display help message and exit

For example, let there be a script "test.vbash" with the following contents:

    PDBID="$1"
    DIR="$(mktemp -d)"
    trap "rm -r $DIR" EXIT
    cd "$DIR"
    curl "https://files.rcsb.org/download/${PDBID}.pdb1.gz" | zcat > "input.pdb"
    [ -s "input.pdb" ] || { echo "Nothing downloaded."; exit 1; }
    v-do "load -file ${DIR}/input.pdb -as-assembly"
    v-do "construct-contacts"
    v-do "voromqa-global"
    v-do "voromqa-local -contacts [-inter-chain]"

The above script can be run non-interactively:

    voronota-scripting-env -i test.vbash 2ZSK

or

    cat test.vbash | voronota-scripting-env 2ZSK

Another way is to start a special bash session:

    bash --init-file "$(which voronota-scripting-env)"

and, inside the session, run the script

    ./test.vbash 2ZSK

EOF
exit 1
}

INFILE=""
INSTRING=""
PASSARGS=()
HELP_MODE=false

while [[ $# > 0 ]]
do
	OPTION="$1"
	OPTARG="$2"
	shift
	case $OPTION in
	-i|--input)
		INFILE="$OPTARG"
		shift
		;;
	-s|--string)
		INSTRING="$OPTARG"
		shift
		;;
	-g|--gui)
		V_GUI=true
		;;
	-t|--no-gui)
		V_GUI=false
		;;
	-h|--help)
		HELP_MODE=true
		;;
	*)
		PASSARGS+=("$OPTION")
		;;
	esac
done

if $HELP_MODE
then
	print_help_and_exit
fi

if [ -n "$INFILE" ] && [ ! -s "$INFILE" ]
then
	echo >&2 "Error: invalid input file '$INFILE'"
	exit 1
fi

if [ -z "$INFILE" ] && [ ! -t 0 ]
then
	INFILE="-"
fi

command -v voronota-resources &> /dev/null || { echo >&2 "Error: 'voronota-resources' executable not in binaries path"; exit 1; }
command -v jq &> /dev/null || { echo >&2 "Error: 'jq' executable not in binaries path"; exit 1; }

if [ "$V_GUI" == "true" ]
then
	command -v voronota-viewer &> /dev/null || { echo >&2 "Error: 'voronota-viewer' executable not in binaries path"; exit 1; }
	coproc VORONOTA_PROC { voronota-viewer; }
else
	command -v voronota &> /dev/null || { echo >&2 "Error: 'voronota' executable not in binaries path"; exit 1; }
	coproc VORONOTA_PROC { voronota run-script --interactive --max-unfolding 0; }
fi

if [ -z "$VORONOTA_PROC_PID" ]
then
	echo >&2 "Error: failed to start Voronota"
	exit 1
fi

FD5_OUTPUT="$(true 2>/dev/null >&5; echo $?)"
FD5_INPUT="$(true 2>/dev/null <&5; echo $?)"
FD6_OUTPUT="$(true 2>/dev/null >&6; echo $?)"
FD6_INPUT="$(true 2>/dev/null <&6; echo $?)"

if [ "$FD5_OUTPUT" == "0" ] || [ "$FD5_INPUT" == "0" ]
then
	echo >&2 "Error: file discriptor 5 not free"
	exit 1
fi

if [ "$FD6_OUTPUT" == "0" ] || [ "$FD6_INPUT" == "0" ]
then
	echo >&2 "Error: file discriptor 6 not free"
	exit 1
fi

exec 5<&${VORONOTA_PROC[0]} 6>&${VORONOTA_PROC[1]}

function on_exit_premature
{
	exec 5<&- 6>&-
}

trap on_exit_premature EXIT

FD5_INPUT="$(true 2>/dev/null <&5; echo $?)"
FD6_OUTPUT="$(true 2>/dev/null >&6; echo $?)"

if [ "$FD5_INPUT" != "0" ] || [ "$FD6_OUTPUT" != "0" ]
then
	echo >&2 "Error: failed to init IO file discriptors 5 and 6"
	exit 1
fi

function v-check-env-app
{
	if [ -n "$VORONOTA_PROC_PID" ] && ps -p "$VORONOTA_PROC_PID" > /dev/null
	then
		return 0
	fi
	echo >&2 "Error: 'voronota-scripting-env' environment has no running Voronota"
	return 1
}

function v-test-env
{
	if v-check-env-app
	then
		echo "echo" >&6
		local V_TEST_OUT
		read V_TEST_OUT <&5
		if [ "$(echo "$V_TEST_OUT" | jq -c '.commands[-1].success')" == "true" ]
		then
			return 0
		fi
	fi
	return 1
}

v-test-env || { echo >&2 "Error: 'voronota-scripting-env' environment not valid"; exit 1; }

function v-unset-utility-variables
{
	unset V_OUT
	unset V_SUCCESS
	unset V_TAIL_OUT
	unset V_TAIL_SUCCESS
}

function v-do-raw
{
	if v-check-env-app
	then
		v-unset-utility-variables
		echo "$*" | tr '\n' ';' | sed 's/;$/\n/' >&6
		read V_OUT <&5
		V_SUCCESS="$(echo "$V_OUT" | jq -c '.script_summary | .commands_successful == .commands_all')"
		V_TAIL_OUT="$(echo "$V_OUT" | jq -c '.commands[-1]')"
		V_TAIL_SUCCESS="$(echo "$V_TAIL_OUT" | jq '.success')"
		echo "$V_OUT"
		return 0
	fi
	return 1
}

function v-do-silent
{
	if v-do-raw "$*" > /dev/null
	then
		return 0
	fi
	return 1
}

function v-do
{
	if v-do-raw "$*" > /dev/null
	then
		echo "$V_OUT" | jq '.'
		return 0
	fi
	return 1
}

readonly V_TMPDIR="$(mktemp -d)"

function on_exit_final
{
	on_exit_premature
	rm -r "$V_TMPDIR"
}

trap on_exit_final EXIT

voronota-resources radii > "$V_TMPDIR/_radii"
voronota-resources voromqa_v1_energy_potential > "$V_TMPDIR/_voromqa_v1_energy_potential"
voronota-resources voromqa_v1_energy_means_and_sds > "$V_TMPDIR/_voromqa_v1_energy_means_and_sds"

v-do-silent "setup-loading --radii-file '$V_TMPDIR/_radii' --include-heteroatoms"
v-do-silent "setup-voromqa --potential '$V_TMPDIR/_voromqa_v1_energy_potential' --means-and-sds '$V_TMPDIR/_voromqa_v1_energy_means_and_sds'"
v-unset-utility-variables

export VORONOTA_PROC_PID
export V_TMPDIR
export V_GUI

export -f v-check-env-app
export -f v-test-env
export -f v-unset-utility-variables
export -f v-do-raw
export -f v-do-silent
export -f v-do

source <(
v-do "list-commands" | jq '.commands[-1].output.outlines[].name' -r | while read CNAME
do
	echo "function v-${CNAME} { v-do \"${CNAME} \$*\"; }"
	echo "export -f v-${CNAME}"
done
)

if command -v voronota-scripting-plugins &> /dev/null
then
	V_PLUGINSDIR="$V_TMPDIR/_plugins"
	mkdir -p "$V_PLUGINSDIR"
	voronota-scripting-plugins list_of_plugins \
	| while read PLUGIN_NAME
	do
		PLUGIN_FILE="$V_PLUGINSDIR/$PLUGIN_NAME"
		voronota-scripting-plugins "$PLUGIN_NAME" > "$PLUGIN_FILE"
		chmod +x "$PLUGIN_FILE"
	done
	export V_PLUGINSDIR
	export PATH="${V_PLUGINSDIR}:${PATH}"
fi

if [ -n "$INFILE" ] || [ -n "$INSTRING" ]
then
	SCRIPTFILE="$V_TMPDIR/_script.bash"
	
	{
		if [ "$INFILE" == "-" ]
		then
			cat
		fi
		
		if [ -n "$INFILE" ]
		then
			cat "$INFILE"
		fi
		
		if [ -n "$INSTRING" ]
		then
			echo "$INSTRING"
		fi
	} \
	| egrep -v '^\S*#' \
	> "$SCRIPTFILE"
	
	chmod +x "$SCRIPTFILE"
	$SCRIPTFILE "${PASSARGS[@]}"
fi

