#!/bin/bash

function print_help_and_exit
{
cat >&2 << EOF

'voronota-cadscore' script is an implementation of CAD-score method using Voronota.

Basic options:
    --input-target | -t             string   *  input target structure file in PDB format
    --input-model | -m              string   *  input model structure file in PDB format
    --input-filter-query            string      input atoms filtering query parameters
    --output-residue-scores         string      output text file with residue scores
    --output-residue-scores-pdb-t   string      output target PDB file with residue scores as B-factors
    --output-residue-scores-pdb-m   string      output model PDB file with residue scores as B-factors
    --smoothing-window              number      residue scores smoothing window size, default is 0
    --contacts-query                string      contacts query parameters
    --contacts-query-by-code        string      contacts query code, possible codes are AA, AS, SS, AM, MM, MS
    --output-coded-global-scores    string      output text file with all coded global scores
    --contacts-query-inter-chain                flag to consider only inter-chain contacts
    --cache-dir                     string      path to cache directory
    --help | -h                                 flag to display help message and exit

Advanced options:
    --multiple-models                           flag to handle multiple models in PDB file
    --old-regime                                flag to calculate areas as in pre-Voronota CAD-score

Standard output (one line):
    {target file path} {model file path} {global score} {number of residue scores}

EOF
exit 1
}

readonly ZEROARG=$0
INFILE_TARGET_PDB=""
INFILE_MODEL_PDB=""
INPUT_FILTER_QUERY_PARAMETERS=""
CONTACTS_QUERY_PARAMETERS=""
CONTACTS_QUERY_BY_CODE=""
CONTACTS_QUERY_INTER_CHAIN=false
OUTFILE_RESIDUE_SCORES=""
OUTFILE_RESIDUE_SCORES_PDB_TARGET=""
OUTFILE_RESIDUE_SCORES_PDB_MODEL=""
OUTFILE_CODED_GLOBAL_SCORES=""
SMOOTHING_WINDOW="0"
CONTACTS_CACHE_DIRECTORY=""
MULTIPLE_MODELS_CHAINS_OPTION=""
OLD_REGIME=false
HELP_MODE=false

while [[ $# > 0 ]]
do
	OPTION="$1"
	OPTARG="$2"
	shift
	case $OPTION in
	-t|--input-target)
		INFILE_TARGET_PDB="$OPTARG"
		shift
		;;
	-m|--input-model)
		INFILE_MODEL_PDB="$OPTARG"
		shift
		;;
	--input-filter-query)
		INPUT_FILTER_QUERY_PARAMETERS="$OPTARG"
		shift
		;;
	--contacts-query)
		CONTACTS_QUERY_PARAMETERS="$OPTARG"
		shift
		;;
	--contacts-query-by-code)
		CONTACTS_QUERY_BY_CODE="$OPTARG"
		shift
		;;
	--contacts-query-inter-chain)
		CONTACTS_QUERY_INTER_CHAIN=true
		;;
	--output-residue-scores)
		OUTFILE_RESIDUE_SCORES="$OPTARG"
		shift
		;;
	--output-residue-scores-pdb-t)
		OUTFILE_RESIDUE_SCORES_PDB_TARGET="$OPTARG"
		shift
		;;
	--output-residue-scores-pdb-m)
		OUTFILE_RESIDUE_SCORES_PDB_MODEL="$OPTARG"
		shift
		;;
	--output-coded-global-scores)
		OUTFILE_CODED_GLOBAL_SCORES="$OPTARG"
		shift
		;;
	--smoothing-window)
		SMOOTHING_WINDOW="$OPTARG"
		shift
		;;
	--cache-dir)
		CONTACTS_CACHE_DIRECTORY="$OPTARG"
		shift
		;;
	--multiple-models)
		MULTIPLE_MODELS_CHAINS_OPTION="--multimodel-chains"
		;;
	--old-regime)
		OLD_REGIME=true
		;;
	-h|--help)
		HELP_MODE=true
		;;
	*)
		echo >&2 "Error: invalid command line option '$OPTION'"
		exit 1
		;;
	esac
done

if [ -z "$INFILE_TARGET_PDB" ] || [ -z "$INFILE_MODEL_PDB" ] || $HELP_MODE
then
	print_help_and_exit
fi

if [[ $ZEROARG == *"/"* ]]
then
	cd $(dirname $ZEROARG)
	export PATH=$(pwd):$PATH
	cd - &> /dev/null
fi

command -v voronota &> /dev/null || { echo >&2 "Error: 'voronota' executable not in binaries path"; exit 1; }
command -v voronota-resources &> /dev/null || { echo >&2 "Error: 'voronota-resources' executable not in binaries path"; exit 1; }

if [ ! -s "$INFILE_TARGET_PDB" ]
then
	echo >&2 "Error: input target file does not exist"
	exit 1
fi

if [ ! -s "$INFILE_MODEL_PDB" ]
then
	echo >&2 "Error: input model file does not exist"
	exit 1
fi

if [ -n "$CONTACTS_QUERY_BY_CODE" ] \
   && [ "$CONTACTS_QUERY_BY_CODE" != "AA" ] \
   && [ "$CONTACTS_QUERY_BY_CODE" != "AS" ] \
   && [ "$CONTACTS_QUERY_BY_CODE" != "SS" ] \
   && [ "$CONTACTS_QUERY_BY_CODE" != "AM" ] \
   && [ "$CONTACTS_QUERY_BY_CODE" != "MM" ] \
   && [ "$CONTACTS_QUERY_BY_CODE" != "MS" ]
then
	echo >&2 "Error: invalid contacts query code '$CONTACTS_QUERY_BY_CODE'"
	exit 1
fi

readonly TMPLDIR=$(mktemp -d)
trap "rm -r $TMPLDIR" EXIT

{
	if [[ "$INFILE_TARGET_PDB" == *".gz" ]]
	then
		zcat "$INFILE_TARGET_PDB"
	else
		cat "$INFILE_TARGET_PDB"
	fi
} > $TMPLDIR/target

{
	if [[ "$INFILE_MODEL_PDB" == *".gz" ]]
	then
		zcat "$INFILE_MODEL_PDB"
	else
		cat "$INFILE_MODEL_PDB"
	fi
} > $TMPLDIR/model

for WORKFILE in $TMPLDIR/target $TMPLDIR/model
do
	cat $WORKFILE \
	| voronota get-balls-from-atoms-file \
	  --annotated $MULTIPLE_MODELS_CHAINS_OPTION \
	  --radii-file <(voronota-resources radii) \
	  --include-heteroatoms \
	| voronota query-balls \
	  --drop-altloc-indicators \
	  --drop-atom-serials \
	| voronota query-balls $INPUT_FILTER_QUERY_PARAMETERS \
	> $WORKFILE.balls
	
	if [ ! -s "$WORKFILE.balls" ]
	then
		echo >&2 "Error: no atoms for $(basename $WORKFILE)"
		exit 1
	fi
	
	BALLS_MD5=""
	if [ -n "$CONTACTS_CACHE_DIRECTORY" ]
	then
		BALLS_MD5=$(cat $WORKFILE.balls | md5sum | awk '{print $1}')
		if [ -n "$BALLS_MD5" ]
		then
			if $OLD_REGIME
			then
				BALLS_MD5="${BALLS_MD5}.voronota.cadscore.old"
			else
				BALLS_MD5="${BALLS_MD5}.voronota.cadscore"
			fi
			if [ -s "$CONTACTS_CACHE_DIRECTORY/$BALLS_MD5" ]
			then
				cp $CONTACTS_CACHE_DIRECTORY/$BALLS_MD5 $WORKFILE.all_contacts
			fi
		fi
	fi

	if [ ! -s "$WORKFILE.all_contacts" ]
	then
		MAIN_CHAIN_ATOMS_DESCRIPTOR="A<CA,C,N,O,OXT>|A<OP3,O3P,P,OP1,O1P,OP2,O2P,O5',O5*,C5',C5*,C4',C4*,O4',O4*,C3',C3*,O3',O3*,C2',C2*,O2',O2*,C1',C1*>"
		
		cat $WORKFILE.balls \
		| \
		{
			if $OLD_REGIME
			then
				voronota calculate-contacts \
				  --annotated \
				  --old-contacts-output $WORKFILE.old_contacts \
				> /dev/null
				cat $WORKFILE.old_contacts
			else
				voronota calculate-contacts \
				  --annotated
			fi
		} \
		| voronota query-contacts \
		  --match-min-seq-sep 1 \
		  --no-solvent \
		| voronota query-contacts \
		  --match-first 'A<C>' \
		  --match-second 'A<N>' \
		  --match-max-seq-sep 1 \
		  --match-max-dist 1.6 \
		  --invert \
		| voronota query-contacts \
		  --set-tags 'AA' \
		| voronota query-contacts \
		  --match-first-not $MAIN_CHAIN_ATOMS_DESCRIPTOR \
		  --match-second-not $MAIN_CHAIN_ATOMS_DESCRIPTOR \
		  --set-tags 'SS' \
		| voronota query-contacts \
		  --match-first $MAIN_CHAIN_ATOMS_DESCRIPTOR \
		  --match-second $MAIN_CHAIN_ATOMS_DESCRIPTOR \
		  --set-tags 'MM' \
		| voronota query-contacts \
		  --match-first-not 'l<m>' \
		  --match-second $MAIN_CHAIN_ATOMS_DESCRIPTOR \
		  --set-tags 'AM' \
		| voronota query-contacts \
		  --match-first-not 'l<m>' \
		  --match-second-not $MAIN_CHAIN_ATOMS_DESCRIPTOR \
		  --set-tags 'AS' \
		| voronota query-contacts \
		  --match-first $MAIN_CHAIN_ATOMS_DESCRIPTOR \
		  --match-first-not 'l<m>' \
		  --match-second-not $MAIN_CHAIN_ATOMS_DESCRIPTOR \
		  --set-tags 'MS' \
		> $WORKFILE.all_contacts
		
		if [ -n "$CONTACTS_CACHE_DIRECTORY" ] && [ -n "$BALLS_MD5" ]
		then
			mkdir -p $CONTACTS_CACHE_DIRECTORY
			cp $WORKFILE.all_contacts $CONTACTS_CACHE_DIRECTORY/$BALLS_MD5
		fi
	fi
	
	cat $WORKFILE.all_contacts \
	| voronota query-contacts $CONTACTS_QUERY_PARAMETERS \
	| \
	{
		if $CONTACTS_QUERY_INTER_CHAIN
		then
			voronota query-contacts --no-same-chain
		else
			cat
		fi
	} \
	| tee $WORKFILE.all_contacts_filtered_not_by_code \
	| \
	{
		if [ -n "$CONTACTS_QUERY_BY_CODE" ]
		then
			voronota query-contacts --match-tags "$CONTACTS_QUERY_BY_CODE"
		else
			cat
		fi
	} \
	> $WORKFILE.contacts
	
	if [ ! -s "$WORKFILE.contacts" ]
	then
		echo >&2 "Error: no contacts for $(basename $WORKFILE)"
		exit 1
	fi
done

cat $TMPLDIR/model.contacts \
| voronota compare-contacts \
  --target-contacts-file $TMPLDIR/target.contacts \
  --smoothing-window $SMOOTHING_WINDOW \
  --smoothed-scores-file $TMPLDIR/smoothed_residue_cad_scores \
  --depth 0 \
> $TMPLDIR/global_cad_scores

if [ -n "$OUTFILE_RESIDUE_SCORES" ]
then
	mkdir -p $(dirname $OUTFILE_RESIDUE_SCORES)
	cp $TMPLDIR/smoothed_residue_cad_scores "$OUTFILE_RESIDUE_SCORES"
fi

if [ -n "$OUTFILE_RESIDUE_SCORES_PDB_TARGET" ]
then
	mkdir -p $(dirname "$OUTFILE_RESIDUE_SCORES_PDB_TARGET")
	cat $TMPLDIR/target.balls \
	| voronota query-balls \
	  --set-external-adjuncts $TMPLDIR/smoothed_residue_cad_scores \
	  --set-external-adjuncts-name score \
	| voronota write-balls-to-atoms-file \
	  --pdb-output "$OUTFILE_RESIDUE_SCORES_PDB_TARGET" \
	  --pdb-output-b-factor score \
	> /dev/null
fi

if [ -n "$OUTFILE_RESIDUE_SCORES_PDB_MODEL" ]
then
	mkdir -p $(dirname "$OUTFILE_RESIDUE_SCORES_PDB_MODEL")
	cat $TMPLDIR/model.balls \
	| voronota query-balls \
	  --set-external-adjuncts $TMPLDIR/smoothed_residue_cad_scores \
	  --set-external-adjuncts-name score \
	| voronota write-balls-to-atoms-file \
	  --pdb-output "$OUTFILE_RESIDUE_SCORES_PDB_MODEL" \
	  --pdb-output-b-factor score \
	> /dev/null
fi

echo $INFILE_TARGET_PDB $INFILE_MODEL_PDB \
  $(cat $TMPLDIR/global_cad_scores | grep 'residue_level_global' | awk '{print $2}') \
  $(cat $TMPLDIR/smoothed_residue_cad_scores | wc -l)

if [ -n "$OUTFILE_CODED_GLOBAL_SCORES" ]
then
	mkdir -p $(dirname "$OUTFILE_CODED_GLOBAL_SCORES")
	for QCODE in AA AS SS AM MM MS
	do
		cat $TMPLDIR/model.all_contacts_filtered_not_by_code \
		| voronota query-contacts --match-tags "$QCODE" \
		| voronota compare-contacts \
		  --target-contacts-file <(cat $TMPLDIR/target.all_contacts_filtered_not_by_code | voronota query-contacts --match-tags "$QCODE") \
		  --depth 0 \
		| grep 'residue_level_global' \
		> $TMPLDIR/coded_global_score_$QCODE
		
		if [ -s "$TMPLDIR/coded_global_score_$QCODE" ]
		then
			echo $QCODE $(cat $TMPLDIR/coded_global_score_$QCODE  | awk '{print $2}')
		else
			echo $QCODE "0"
		fi
	done > "$OUTFILE_CODED_GLOBAL_SCORES"
fi
